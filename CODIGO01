import numpy as np
import pandas as pd
import matplotlib.pyplot as plt

## Se considera que solo se usar√° la seccion VI del PCI para las 3 longitudes 35, 25, 15
## Se tienen los 9 puntos de analisis de la viga

## DEFINIR LOS PAR√ÅMETROS GEOM√âTRICOS DE LA VIGA Y NODOS DE INTER√âS
## PARA EVITAR CONFUSIONES TODAS MAS MEDIDAS DE LONGITUD SON EN METROS

##-----------------------------------------##
LTOTAL=40
PIZAJE= 0 # Ton
SXNVIGA= "VI"
PA=0.7
PEN= 0.924
PIF=0.30523
PID=0.02563
PESO=24  # kN/m3
PTOR= 0.01555 #m^4
PCW= 0.00653 #m^6
fc=49 # MPa

# -------------------------------
# √Ångulo de inclinaci√≥n de la viga
# -------------------------------
Grados = 0               # √Ångulo en grados (entrada del modelo)
alpha = np.deg2rad(Grados) # Conversi√≥n a radianes

##-----------------------------------------##

#MIRAR TABLAS PARA COLOCAR VALORES GEOM---------------------------------------------------------------------------------

#DEFINIR NODOS Y POSICIONES

##-----------------------------------------##
a_L = 0.05       # Relaci√≥n a/L
h = 1.8         # Distancia h desde los puntos de izaje (m)
##-----------------------------------------##

# =====================================================================
# PAR√ÅMETROS DE PRETENSADO
# =====================================================================
CONSIDERAR_PRETENSADO = True  # True/False para activar/desactivar

P_pretensado = 10000  # kN - Fuerza de pretensado
e_pretensado = 0.65  # m  - Excentricidad en el centro

print(f"\nPretensado: {'ACTIVADO' if CONSIDERAR_PRETENSADO else 'DESACTIVADO'}")
if CONSIDERAR_PRETENSADO:
    print(f"  P = {P_pretensado} kN")
    print(f"  e = {e_pretensado} m")






a = a_L * LTOTAL

# -------------------------------
# 3. Funci√≥n para limitar nodos al dominio [0, L]
# -------------------------------
def limitar(x, LTOTAL):
    return max(0.0, min(x, LTOTAL))

# -------------------------------
# 4. Posici√≥n de los 9 nodos (con control geom√©trico)
# -------------------------------
nodos = np.array([
    0.0,                          # Extremo izquierdo
    limitar(a - h, LTOTAL),            # Antes izaje izquierdo
    a,                            # Izaje izquierdo
    limitar(a + h, LTOTAL),            # Despu√©s izaje izquierdo
    LTOTAL / 2,                        # Mitad de la viga
    limitar(LTOTAL - a - h, LTOTAL),        # Antes izaje derecho
    LTOTAL - a,                        # Izaje derecho
    limitar(LTOTAL - a + h, LTOTAL),        # Despu√©s izaje derecho
    LTOTAL                             # Extremo derecho
])

# -------------------------------
# 5. Organizaci√≥n visual
# -------------------------------
df_nodos = pd.DataFrame({
    "Nodo": [f"N{i+1}" for i in range(len(nodos))],
    "Posici√≥n [m]": nodos.round(3)
})

df_nodos

print(df_nodos.to_string(index=False))


nodos = np.array(nodos)
num_nodos = len(nodos)

plt.figure(figsize=(16, 3))

# Dibujo de la viga
plt.hlines(y=0, xmin=0, xmax=LTOTAL, linewidth=6)
plt.scatter(nodos, np.zeros_like(nodos), s=80, zorder=3)

# Alternar etiquetas arriba y abajo
offsets = [0.25 if i % 2 == 0 else -0.35 for i in range(num_nodos)]

for i, (x, dy) in enumerate(zip(nodos, offsets)):
    plt.annotate(
        f"N{i+1}\n{x:.2f} m",
        xy=(x, 0),
        xytext=(x, dy),
        textcoords="data",
        ha="center",
        fontsize=9,
        arrowprops=dict(arrowstyle="-", lw=0.8)
    )

# Etiqueta del centro
plt.text(LTOTAL / 2, 0.55, f"Viga ‚Äì Longitud total = {LTOTAL:.2f} m",
         ha="center", fontsize=12, fontweight="bold")

# Est√©tica
plt.yticks([])
plt.xlabel("Posici√≥n a lo largo de la viga [m]")
plt.xlim(-0.5, LTOTAL + 0.5)
plt.ylim(-0.6, 0.8)
plt.grid(axis="x", linestyle="--", alpha=0.4)

plt.tight_layout()
plt.show()



## PARTE DE LA MATRIZ DE AQU√ç EN ADELANTE ------------------------------------------------------------------------------------------------------------------

# -------------------------------
# 1. Definir etiquetas de filas y columnas
# -------------------------------
labels = [
    "u1","v1","w1","Œ∏x1","Œ∏y1","Œ∏z1","Œ∏'x1",
    "u2","v2","w2","Œ∏x2","Œ∏y2","Œ∏z2","Œ∏'x2"
]

# -------------------------------
# 1. Matriz original con letras
# -------------------------------
K_letras = np.array([
["A","0","0","0","0","0","0","-A","0","0","0","0","0","0"],
["0","B","0","0","0","G","0","0","-B","0","0","0","G","0"],
["0","0","C","0","-H","0","0","0","0","-C","0","-H","0","0"],
["0","0","0","D","0","0","I","0","0","0","-D","0","0","I"],
["0","0","-H","0","E","0","0","0","0","H","0","L","0","0"],
["0","G","0","0","0","F","0","0","-G","0","0","0","M","0"],
["0","0","0","I","0","0","K","0","0","0","-I","0","0","-J"],

["-A","0","0","0","0","0","0","A","0","0","0","0","0","0"],
["0","-B","0","0","0","-G","0","0","B","0","0","0","-G","0"],
["0","0","-C","0","H","0","0","0","0","C","0","H","0","0"],
["0","0","0","-D","0","0","-I","0","0","0","D","0","0","-I"],
["0","0","-H","0","L","0","0","0","0","H","0","E","0","0"],
["0","G","0","0","0","M","0","0","-G","0","0","0","F","0"],
["0","0","0","I","0","0","-J","0","0","0","-I","0","0","K"]
], dtype=object)

# -------------------------------
# 2. Valores de las letras
# -------------------------------
#Variables para las letras:

Ls=LTOTAL/8 
A=PA


# DESPU√âS (CCP-14):
K1 = 1.0
wc = 2400  # kg/m¬≥
E_MPa = 0.043 * K1 * (wc**1.5) * np.sqrt(fc)
E = E_MPa * 1000


Iy=PID
Iz=PIF
v=0.2
G_shear=E/(2*(1+v))
Cw=PCW
J=PTOR
q = PESO*A #kN/m


ndof_nodo = 7
num_nodos = len(nodos)
ndof_total = ndof_nodo * num_nodos

K_global = np.zeros((ndof_total, ndof_total))

def matriz_elemental(Ls):
    if Ls <= 0:
        return None

    valores = {
         "A": (E*A)/Ls,
        "B": (12*E*Iz)/(Ls**3),      # ‚úì Usa Iz para v
        "C": (12*E*Iy)/(Ls**3),      # ‚úì Usa Iy para w
        "D": ((6*G_shear*J)/(5*Ls))+((12*E*Cw)/(Ls**3)),
        "E": (4*E*Iy)/Ls,             # ‚úì Usa Iy para Œ∏y
        "F": (4*E*Iz)/Ls,             # ‚úì Usa Iz para Œ∏z
        "G": (6*E*Iz)/(Ls**2),       # ‚úì Usa Iz para acoplamiento v-Œ∏z
        "H": (6*E*Iy)/(Ls**2),       # ‚úì Usa Iy para acoplamiento w-Œ∏y
        "I": ((G_shear*J)/(10))+((6*E*Cw)/(Ls**2)),
        "J": ((G_shear*J*Ls)/(30))-((2*E*Cw)/(Ls)),
        "K": ((2*G_shear*J*Ls)/(15))+((4*E*Cw)/(Ls)),
        "L": (E*Iy*2)/Ls,             # ‚úì Usa Iy
        "M": (E*Iz*2)/Ls              # ‚úì Usa Iz
    }
    


    def convertir(valor):
        if valor == "0":
            return 0.0
        if valor.startswith("-"):
            return -valores[valor[1:]]
        return valores[valor]

    return np.vectorize(convertir)(K_letras)

for i in range(num_nodos - 1):

    xi = nodos[i]
    xj = nodos[i + 1]
    Ls = xj - xi

    # Si el segmento no existe (nodos coinciden)
    if Ls <= 0:
        continue

    Ke = matriz_elemental(Ls)

    # GDL globales del nodo i y i+1
    dofs_i = np.arange(i*7, i*7 + 7)
    dofs_j = np.arange((i+1)*7, (i+1)*7 + 7)

    dofs = np.concatenate([dofs_i, dofs_j])

    # Ensamblaje
    for a in range(14):
        for b in range(14):
            K_global[dofs[a], dofs[b]] += Ke[a, b]

labels_global = []
for i in range(num_nodos):
    labels_global += [
        f"u{i+1}", f"v{i+1}", f"w{i+1}",
        f"Œ∏x{i+1}", f"Œ∏y{i+1}", f"Œ∏z{i+1}", f"Œ∏'x{i+1}"
    ]

df_K_global = pd.DataFrame(K_global, index=labels_global, columns=labels_global)
df_K_global



# -------------------------------
# VECTOR DE CARGAS NODALES (63 x 1)
# -------------------------------

# Inicializar vector de fuerzas (7 DOF √ó num_nodos)
F_global = np.zeros(ndof_total)

# Carga distribuida (ya la tienes definida)
# q = PESO * PA  # kN/m

# =====================================================================
# C√ÅLCULO DE FUERZAS DE PRETENSADO
# =====================================================================
F_pretensado = np.zeros(ndof_total)

if CONSIDERAR_PRETENSADO:
    print("\n" + "="*70)
    print("CALCULANDO FUERZAS DE PRETENSADO")
    print("="*70)
    
    L = LTOTAL
    P = P_pretensado
    e = e_pretensado
    
    # 1. Fuerzas axiales en extremos
    F_pretensado[0 * 7 + 0] = P      # u1 = +P
    F_pretensado[8 * 7 + 0] = -P     # u9 = -P
    print(f"‚úì Fuerzas axiales: N1: +{P} kN, N9: -{P} kN")
    
    # 2. Fuerzas verticales en extremos
    F_vert_extremo = 3 * P * e / L
    F_pretensado[0 * 7 + 1] = F_vert_extremo  # v1
    F_pretensado[8 * 7 + 1] = F_vert_extremo  # v9
    print(f"‚úì Fuerzas verticales extremos: {F_vert_extremo:.4f} kN")
    
    # 3. Transferir cargas en L/3 y 2L/3
    pos_carga_izq = L / 3
    pos_carga_der = 2 * L / 3
    P_carga = 3 * P * e / L
    
    # Carga izquierda
    tolerancia = 1e-6
    nodos_izq_L3 = nodos[nodos <= pos_carga_izq]
    nodos_der_L3 = nodos[nodos >= pos_carga_izq]
    
    if len(nodos_izq_L3) > 0 and len(nodos_der_L3) > 0:
        idx_izq_i = len(nodos_izq_L3) - 1
        idx_der_i = len(nodos_izq_L3)
        pos_izq_i = nodos[idx_izq_i]
        pos_der_i = nodos[idx_der_i]
        
        if abs(pos_carga_izq - pos_izq_i) < tolerancia:
            F_pretensado[idx_izq_i * 7 + 1] += P_carga
        elif abs(pos_carga_izq - pos_der_i) < tolerancia:
            F_pretensado[idx_der_i * 7 + 1] += P_carga
        else:
            a_i = pos_carga_izq - pos_izq_i
            b_i = pos_der_i - pos_carga_izq
            L_elem_i = pos_der_i - pos_izq_i
            
            v_izq = P_carga * (b_i**2) * (3*a_i + b_i) / (L_elem_i**3)
            v_der = P_carga * (a_i**2) * (a_i + 3*b_i) / (L_elem_i**3)
            M_izq = P_carga * a_i * (b_i**2) / (L_elem_i**2)
            M_der = -P_carga * (a_i**2) * b_i / (L_elem_i**2)
            
            F_pretensado[idx_izq_i * 7 + 1] += v_izq
            F_pretensado[idx_izq_i * 7 + 3] += M_izq
            F_pretensado[idx_der_i * 7 + 1] += v_der
            F_pretensado[idx_der_i * 7 + 3] += M_der
    
    # Carga derecha
    nodos_izq_2L3 = nodos[nodos <= pos_carga_der]
    nodos_der_2L3 = nodos[nodos >= pos_carga_der]
    
    if len(nodos_izq_2L3) > 0 and len(nodos_der_2L3) > 0:
        idx_izq_d = len(nodos_izq_2L3) - 1
        idx_der_d = len(nodos_izq_2L3)
        pos_izq_d = nodos[idx_izq_d]
        pos_der_d = nodos[idx_der_d]
        
        if abs(pos_carga_der - pos_izq_d) < tolerancia:
            F_pretensado[idx_izq_d * 7 + 1] += P_carga
        elif abs(pos_carga_der - pos_der_d) < tolerancia:
            F_pretensado[idx_der_d * 7 + 1] += P_carga
        else:
            a_d = pos_carga_der - pos_izq_d
            b_d = pos_der_d - pos_carga_der
            L_elem_d = pos_der_d - pos_izq_d
            
            v_izq = P_carga * (b_d**2) * (3*a_d + b_d) / (L_elem_d**3)
            v_der = P_carga * (a_d**2) * (a_d + 3*b_d) / (L_elem_d**3)
            M_izq = P_carga * a_d * (b_d**2) / (L_elem_d**2)
            M_der = -P_carga * (a_d**2) * b_d / (L_elem_d**2)
            
            F_pretensado[idx_izq_d * 7 + 1] += v_izq
            F_pretensado[idx_izq_d * 7 + 3] += M_izq
            F_pretensado[idx_der_d * 7 + 1] += v_der
            F_pretensado[idx_der_d * 7 + 3] += M_der
    
    print(f"‚úì Cargas en L/3 y 2L/3 transferidas a nodos")
    

# =====================================================================
# MOSTRAR MATRIZ DE FUERZAS DE PRETENSADO (63√ó1)
# =====================================================================
print("\n" + "="*70)
print("MATRIZ DE FUERZAS DE PRETENSADO (63√ó1)")
print("="*70)

# Crear DataFrame con el vector completo
df_F_pretensado = pd.DataFrame({
    "Fila": np.arange(1, ndof_total + 1),
    "DOF": labels_global,
    "F_pretensado (kN o kN¬∑m)": F_pretensado
})

# Mostrar solo componentes no nulas
df_F_pretensado_nonzero = df_F_pretensado[np.abs(df_F_pretensado["F_pretensado (kN o kN¬∑m)"]) > 1e-10]
print("\nComponentes no nulas:")
print(df_F_pretensado_nonzero.to_string(index=False))

# Organizar por nodos para visualizaci√≥n
print("\n" + "="*70)
print("FUERZAS DE PRETENSADO POR NODO")
print("="*70)
matriz_pretensado_nodos = []
for i in range(num_nodos):
    base = i * 7
    matriz_pretensado_nodos.append([
        f"N{i+1}",
        nodos[i],
        F_pretensado[base + 0],  # u
        F_pretensado[base + 1],  # v
        F_pretensado[base + 2],  # w
        F_pretensado[base + 3],  # Œ∏x
        F_pretensado[base + 4],  # Œ∏y
        F_pretensado[base + 5],  # Œ∏z
        F_pretensado[base + 6]   # Œ∏'x
    ])

df_pretensado_nodos = pd.DataFrame(matriz_pretensado_nodos, columns=[
    'Nodo', 'Pos (m)', 'u (kN)', 'v (kN)', 'w (kN)', 
    'Œ∏x (kN¬∑m)', 'Œ∏y (kN¬∑m)', 'Œ∏z (kN¬∑m)', "Œ∏'x (kN¬∑m¬≤)"
])
print("\n" + df_pretensado_nodos.to_string(index=False))



# -------------------------------
# 1. CARGAS DISTRIBUIDAS EN ELEMENTOS
# -------------------------------
for i in range(num_nodos - 1):
    xi = nodos[i]
    xj = nodos[i + 1]
    Ls = xj - xi
    
    if Ls <= 0:
        continue
    
    # Componentes de la carga
    qv = q * np.cos(alpha)  # Componente vertical de la carga
    qh = q * np.sin(alpha)  # Componente horizontal de la carga
    
    # Fuerzas nodales equivalentes para carga distribuida
    Fv_i = -(qv * Ls) / 2
    Fv_j = -(qv * Ls) / 2
    
    Fh_i = -(qh * Ls) / 2
    Fh_j = -(qh * Ls) / 2
    
    # Momentos en el plano z
    Mz_i = -(qv * Ls**2) / 12
    Mz_j = (qv * Ls**2) / 12

    # Momentos en el plano y
    My_i = -(qh * Ls**2) / 12
    My_j = (qh * Ls**2) / 12
    
    # Ensamblar en el vector global
    dof_base_i = i * 7
    dof_base_j = (i + 1) * 7
    
    # Nodo i
    F_global[dof_base_i + 2] += Fh_i      # u (horizontal)
    F_global[dof_base_i + 1] += Fv_i      # v (vertical)
    F_global[dof_base_i + 5] += Mz_i      # Œ∏z (momento flexi√≥n)
    F_global[dof_base_i + 4] += My_i      # Œ∏y (momento comp horizontal)
    
    # Nodo j
    F_global[dof_base_j + 2] += Fh_j      # u (horizontal)
    F_global[dof_base_j + 1] += Fv_j      # v (vertical)
    F_global[dof_base_j + 5] += Mz_j      # Œ∏z (momento flexi√≥n)
    F_global[dof_base_j + 4] += My_j      # Œ∏y (momento comp horizontal)

# -------------------------------
# 2. AGREGAR CARGAS DE IZAJE
# -------------------------------
# Definir la carga de izaje
qizaje = PIZAJE # Fuerza total en cada punto de izaje [kN]

# Aplicar carga de izaje en Nodo 3 (√≠ndice 2) - solo componente vertical
F_global[2*7 + 1] += qizaje  # v3 (fuerza vertical hacia arriba, positiva)

# Aplicar carga de izaje en Nodo 7 (√≠ndice 6) - solo componente vertical
F_global[6*7 + 1] += qizaje  # v7 (fuerza vertical hacia arriba, positiva)

#-----------------------------------------------------ESTO SE COLOCA PARA UNIR MATRICES DE PRETENSADO CON LAS DE IZAJE Y CARGAS 
F_global = F_global + F_pretensado 



# -------------------------------
# VISUALIZACI√ìN COMPLETA: 63 FILAS (9 nodos √ó 7 GDL)
# -------------------------------
print("\n" + "="*70)
print("VECTOR DE CARGAS NODALES - MATRIZ 63x1")
print("="*70)
print(f"Dimensi√≥n de la matriz: {F_global.shape}")
print(f"Carga de izaje aplicada: qizaje = {qizaje:.4f} Ton en N3 y N7")
print("="*70)
print(f"{'Fila':<6} {'DOF':<8} {'Valor [kN o kN¬∑m]':<20}")
print("-"*70)

for i in range(ndof_total):
    nodo_num = (i // 7) + 1
    gdl_local = i % 7
    gdl_nombres = ["u", "v", "w", "Œ∏x", "Œ∏y", "Œ∏z", "Œ∏'x"]
    dof_label = f"{gdl_nombres[gdl_local]}{nodo_num}"
    
    # Marcar con asterisco los nodos de izaje
    marca = ""
    if (i == 2*7 + 1) or (i == 6*7 + 1):  # v3 o v7
        marca = " ‚Üê IZAJE"
    
    print(f"{i+1:<6} {dof_label:<8} {F_global[i]:>19.4f}{marca}")

# -------------------------------
# TAMBI√âN COMO DATAFRAME
# -------------------------------
df_F_completo = pd.DataFrame({
    "Fila": np.arange(1, ndof_total + 1),
    "DOF": labels_global,
    "Fuerza [kN] o Momento [kN¬∑m]": F_global.round(4)
})

print("\n" + "="*70)
print("FORMATO TABLA")
print("="*70)
print(df_F_completo.to_string(index=False))

# -------------------------------
# Resumen visual por nodos
# -------------------------------
print("\n" + "="*110)
print("RESUMEN ORGANIZADO POR NODOS (9 nodos √ó 7 GDL cada uno)")
print("="*110)
print(f"{'Nodo':<8} {'u (kN)':<13} {'v (kN)':<13} {'w (kN)':<13} {'Œ∏x (kN¬∑m)':<13} {'Œ∏y (kN¬∑m)':<13} {'Œ∏z (kN¬∑m)':<13} {'Œ∏\\x (kN¬∑m)':<13}")
print("-"*110)

for i in range(num_nodos):
    base = i * 7
    nodo_label = f"N{i+1}"
    if i == 2 or i == 6:  # Marcar nodos de izaje
        nodo_label += " (izaje)"
    
    print(f"{nodo_label:<8} "
          f"{F_global[base+0]:>12.4f} "
          f"{F_global[base+1]:>12.4f} "
          f"{F_global[base+2]:>12.4f} "
          f"{F_global[base+3]:>12.4f} "
          f"{F_global[base+4]:>12.4f} "
          f"{F_global[base+5]:>12.4f} "
          f"{F_global[base+6]:>12.4f}")

print("\nTotal de GDL: {} (9 nodos √ó 7 GDL/nodo)".format(ndof_total))



# -------------------------------
# CONDICIONES DE FRONTERA
# -------------------------------
# Los puntos de izaje no tienen desplazamiento vertical
# Nodo 3 (√≠ndice 2): v3 restringido
# Nodo 7 (√≠ndice 6): v7 restringido

dofs_restringidos = [
    # Nodo 3 (izaje izquierdo) - punto de apoyo
    2*7 + 0,  # u3 = 0 (sin desplazamiento horizontal)
    2*7 + 1,  # v3 = 0 (sin desplazamiento vertical)
    2*7 + 2,  # w3 = 0 (sin desplazamiento lateral)
    
    # Nodo 7 (izaje derecho) - punto de apoyo
    6*7 + 1,  # v7 = 0 (sin desplazamiento vertical)
    6*7 + 2,  # w7 = 0 (sin desplazamiento lateral)
]

# Todos los DOF libres (los que no est√°n restringidos)
dofs_libres = np.setdiff1d(np.arange(ndof_total), dofs_restringidos)

print("\n" + "="*70)
print("CONDICIONES DE FRONTERA")
print("="*70)
print(f"Total de GDL: {ndof_total}")
print(f"GDL restringidos: {len(dofs_restringidos)}")
print(f"GDL libres: {len(dofs_libres)}")
print("\nGDL restringidos:")
for dof in dofs_restringidos:
    print(f"  - Fila {dof+1}: {labels_global[dof]} = 0 (sin desplazamiento)")

# -------------------------------
# PARTICIONAR LA MATRIZ DE RIGIDEZ Y VECTOR DE CARGAS
# -------------------------------
# Extraer submatrices
K_libre = K_global[np.ix_(dofs_libres, dofs_libres)]
F_libre = F_global[dofs_libres]

print("\n" + "="*70)
print("SISTEMA REDUCIDO")
print("="*70)
print(f"Matriz de rigidez reducida K_libre: {K_libre.shape}")
print(f"Vector de cargas reducido F_libre: {F_libre.shape}")

# -------------------------------
# RESOLVER EL SISTEMA: K_libre * u_libre = F_libre
# -------------------------------
print("\n" + "="*70)
print("RESOLVIENDO SISTEMA DE ECUACIONES...")
print("="*70)

u_libre = np.linalg.solve(K_libre, F_libre)

print(f"‚úì Sistema resuelto exitosamente")
print(f"  Desplazamientos libres calculados: {u_libre.shape}")

# -------------------------------
# ENSAMBLAR VECTOR COMPLETO DE DESPLAZAMIENTOS (63√ó1)
# -------------------------------
u_global = np.zeros(ndof_total)
u_global[dofs_libres] = u_libre
# Los DOF restringidos quedan en cero (v3=0, v7=0)

# -------------------------------
# C√ÅLCULO DE REACCIONES: R = K¬∑u - F
# -------------------------------
print("\n" + "="*80)
print("C√ÅLCULO DE REACCIONES EN LOS APOYOS")
print("="*80)

# Calcular fuerzas internas totales
F_int_total = K_global @ u_global

# Calcular reacciones
R_global = F_int_total - F_global

# Extraer solo reacciones en GDL restringidos
R_restringidos = R_global[dofs_restringidos]

# -------------------------------
# RESUMEN POR NODO DE APOYO
# -------------------------------
# Nodo 3 (izaje izquierdo)
base_n3 = 2 * 7
R_u3 = R_global[base_n3 + 0]  # Reacci√≥n horizontal
R_v3 = R_global[base_n3 + 1]  # Reacci√≥n vertical
R_w3 = R_global[base_n3 + 2]  # Reacci√≥n lateral

# Nodo 7 (izaje derecho)
base_n7 = 6 * 7
R_v7 = R_global[base_n7 + 1]  # Reacci√≥n vertical
R_w7 = R_global[base_n7 + 2]  # Reacci√≥n lateral

print(f"\nNODO 3 (Izaje Izquierdo):")
print(f"  R_u3 (horizontal): {R_u3:>12.6f} kN")
print(f"  R_v3 (vertical):   {R_v3:>12.6f} kN")
print(f"  R_w3 (lateral):    {R_w3:>12.6f} kN")

print(f"\nNODO 7 (Izaje Derecho):")
print(f"  R_v7 (vertical):   {R_v7:>12.6f} kN")
print(f"  R_w7 (lateral):    {R_w7:>12.6f} kN")

# -------------------------------
# VERIFICACI√ìN DE EQUILIBRIO
# -------------------------------
peso_total = q * LTOTAL
izaje_total = 2 * qizaje
R_vertical_total = R_v3 + R_v7

print(f"\n{'='*60}")
print("VERIFICACI√ìN DE EQUILIBRIO VERTICAL:")
print(f"{'='*60}")
print(f"Peso (‚Üì):        {-peso_total:>12.6f} kN")
print(f"Izaje (‚Üë):       {izaje_total:>12.6f} kN")
print(f"Reacciones (‚Üë):  {R_vertical_total:>12.6f} kN")
print(f"{'-'*60}")
suma = -peso_total + izaje_total + R_vertical_total
print(f"Suma (‚âà0):       {suma:>12.6f} kN")

if abs(suma) < 1e-6:
    print("‚úì Equilibrio VERIFICADO")



## üìä **Lo que obtendr√°s:**

### **Reacciones en Nodo 3 (izaje izquierdo):**
#- **R_u3** = Fuerza horizontal (si restringiste u3)
#- **R_v3** = Fuerza vertical (peso que soporta este punto)
# **R_w3** = Fuerza lateral (si restringiste w3)

### **Reacciones en Nodo 7 (izaje derecho):**
# **R_v7** = Fuerza vertical (peso que soporta este punto)
#- **R_w7** = Fuerza lateral (si restringiste w7)



## üéØ **Interpretaci√≥n f√≠sica:**

#Si la viga pesa 336 kN y no hay izaje (PIZAJE=0):
#‚Üí R_v3 + R_v7 ‚âà 336 kN

#Si adem√°s aplicas izaje de 168 kN en cada punto:
#‚Üí Peso total: -336 kN (‚Üì)
#‚Üí Izaje total: +336 kN (‚Üë)
#‚Üí Reacciones: ‚âà0 kN (viga "flotando")



# -------------------------------
# VISUALIZACI√ìN DE DESPLAZAMIENTOS
# -------------------------------
print("\n" + "="*70)
print("VECTOR DE DESPLAZAMIENTOS - MATRIZ 63√ó1")
print("="*70)
print(f"{'Fila':<6} {'DOF':<8} {'Desplazamiento':<20} {'Unidad':<10}")
print("-"*70)

for i in range(ndof_total):
    nodo_num = (i // 7) + 1
    gdl_local = i % 7
    gdl_nombres = ["u", "v", "w", "Œ∏x", "Œ∏y", "Œ∏z", "Œ∏'x"]
    dof_label = f"{gdl_nombres[gdl_local]}{nodo_num}"
    
    # Determinar unidad
    if gdl_local in [0, 1, 2]:  # u, v, w
        unidad = "m"
    else:  # rotaciones
        unidad = "rad"
    
    # Marcar DOF restringidos
    marca = ""
    if i in dofs_restringidos:
        marca = " ‚Üê RESTRINGIDO"
    
    print(f"{i+1:<6} {dof_label:<8} {u_global[i]:>19.6e} {unidad:<10}{marca}")

# -------------------------------
# RESUMEN POR NODOS
# -------------------------------
print("\n" + "="*130)
print("DESPLAZAMIENTOS ORGANIZADOS POR NODOS")
print("="*130)
print(f"{'Nodo':<8} {'u (m)':<15} {'v (m)':<15} {'w (m)':<15} {'Œ∏x (rad)':<15} {'Œ∏y (rad)':<15} {'Œ∏z (rad)':<15} {'Œ∏\\x (rad)':<15}")
print("-"*130)

for i in range(num_nodos):
    base = i * 7
    nodo_label = f"N{i+1}"
    if i == 2 or i == 6:  # Marcar nodos de izaje
        nodo_label += " *"
    
    print(f"{nodo_label:<8} "
          f"{u_global[base+0]:>14.6e} "
          f"{u_global[base+1]:>14.6e} "
          f"{u_global[base+2]:>14.6e} "
          f"{u_global[base+3]:>14.6e} "
          f"{u_global[base+4]:>14.6e} "
          f"{u_global[base+5]:>14.6e} "
          f"{u_global[base+6]:>14.6e}")

print("\n* = Puntos de izaje (v3=0, v7=0)")

# -------------------------------
# DESPLAZAMIENTOS M√ÅXIMOS
# -------------------------------
print("\n" + "="*70)
print("DESPLAZAMIENTOS M√ÅXIMOS")
print("="*70)

# Desplazamientos verticales (v)
v_values = [u_global[i*7 + 1] for i in range(num_nodos)]
max_v_idx = np.argmax(np.abs(v_values))
print(f"M√°ximo desplazamiento vertical:")
print(f"  Nodo N{max_v_idx+1}: v = {v_values[max_v_idx]:.6e} m")

# Desplazamientos horizontales (u)
u_values = [u_global[i*7 + 0] for i in range(num_nodos)]
max_u_idx = np.argmax(np.abs(u_values))
print(f"\nM√°ximo desplazamiento horizontal:")
print(f"  Nodo N{max_u_idx+1}: u = {u_values[max_u_idx]:.6e} m")

# Rotaciones Œ∏x
theta_x_values = [u_global[i*7 + 3] for i in range(num_nodos)]
max_theta_idx = np.argmax(np.abs(theta_x_values))
print(f"\nM√°xima rotaci√≥n Œ∏x:")
print(f"  Nodo N{max_theta_idx+1}: Œ∏x = {theta_x_values[max_theta_idx]:.6e} rad")


# -------------------------------
# C√ÅLCULO DE ESFUERZOS EN CADA NODO
# -------------------------------

print("\n" + "="*100)
print("C√ÅLCULO DE ESFUERZOS INTERNOS EN CADA NODO")
print("="*100)

# Inicializar matriz de esfuerzos nodales (9 nodos √ó 7 esfuerzos)
# Esfuerzos: [N, Vy, Vz, Tx, My, Mz, Bx]
esfuerzos_nodales = np.zeros((num_nodos, 7))

# -------------------------------
# CALCULAR ESFUERZOS NODO POR NODO
# -------------------------------
for i_nodo in range(num_nodos):
    
    # Inicializar acumulador de fuerzas en el nodo
    F_nodo = np.zeros(7)
    
    # -------------------------------
    # Contribuci√≥n del elemento a la IZQUIERDA (si existe)
    # -------------------------------
    if i_nodo > 0:  # Si no es el primer nodo
        i_elem = i_nodo - 1  # √çndice del elemento a la izquierda
        xi = nodos[i_elem]
        xj = nodos[i_elem + 1]
        Ls = xj - xi
        
        if Ls > 0:
            # Extraer desplazamientos del elemento
            dofs_i = np.arange(i_elem*7, i_elem*7 + 7)
            dofs_j = np.arange((i_elem+1)*7, (i_elem+1)*7 + 7)
            u_elemento = np.concatenate([u_global[dofs_i], u_global[dofs_j]])
            
            # Calcular fuerzas internas del elemento
            Ke = matriz_elemental(Ls)
            F_interno = Ke @ u_elemento
            
            # Extraer fuerzas en el nodo j del elemento (que corresponde al nodo actual)
            F_nodo += F_interno[7:14]  # Fuerzas en el extremo derecho del elemento
    
    # -------------------------------
    # Contribuci√≥n del elemento a la DERECHA (si existe)
    # -------------------------------
    if i_nodo < num_nodos - 1:  # Si no es el √∫ltimo nodo
        i_elem = i_nodo  # √çndice del elemento a la derecha
        xi = nodos[i_elem]
        xj = nodos[i_elem + 1]
        Ls = xj - xi
        
        if Ls > 0:
            # Extraer desplazamientos del elemento
            dofs_i = np.arange(i_elem*7, i_elem*7 + 7)
            dofs_j = np.arange((i_elem+1)*7, (i_elem+1)*7 + 7)
            u_elemento = np.concatenate([u_global[dofs_i], u_global[dofs_j]])
            
            # Calcular fuerzas internas del elemento
            Ke = matriz_elemental(Ls)
            F_interno = Ke @ u_elemento
            
            # Extraer fuerzas en el nodo i del elemento (que corresponde al nodo actual)
            # NOTA: Cambiar signo porque estamos mirando desde el otro lado
            F_nodo -= F_interno[0:7]  # Fuerzas en el extremo izquierdo del elemento
    
    # Guardar esfuerzos del nodo
    esfuerzos_nodales[i_nodo, :] = F_nodo

# -------------------------------
# CREAR DATAFRAME CON LOS RESULTADOS
# -------------------------------
df_esfuerzos_nodos = pd.DataFrame(
    esfuerzos_nodales,
    columns=['N (kN)', 'Vy (kN)', 'Vz (kN)', 'Tx (kN¬∑m)', 'My (kN¬∑m)', 'Mz (kN¬∑m)', 'Bx (kN¬∑m¬≤)'],
    index=[f'N{i+1}' for i in range(num_nodos)]
)

df_esfuerzos_nodos.insert(0, 'Posici√≥n (m)', nodos)

print("\n" + "="*140)
print("TABLA DE ESFUERZOS EN CADA NODO")
print("="*140)
print(df_esfuerzos_nodos.to_string())

# -------------------------------
# FORMATO ALTERNATIVO: LISTA COMPLETA
# -------------------------------
print("\n" + "="*100)
print("ESFUERZOS NODALES - FORMATO DETALLADO")
print("="*100)
print(f"{'Nodo':<8} {'Posici√≥n (m)':<15} {'N (kN)':<12} {'Vy (kN)':<12} {'Vz (kN)':<12} {'Tx (kN¬∑m)':<12} {'My (kN¬∑m)':<12} {'Mz (kN¬∑m)':<12}")
print("-"*100)

for i in range(num_nodos):
    nodo_label = f"N{i+1}"
    if i == 2 or i == 6:  # Marcar nodos de izaje
        nodo_label += " *"
    
    print(f"{nodo_label:<8} "
          f"{nodos[i]:>14.3f} "
          f"{esfuerzos_nodales[i, 0]:>11.4f} "
          f"{esfuerzos_nodales[i, 1]:>11.4f} "
          f"{esfuerzos_nodales[i, 2]:>11.4f} "
          f"{esfuerzos_nodales[i, 3]:>11.4f} "
          f"{esfuerzos_nodales[i, 4]:>11.4f} "
          f"{esfuerzos_nodales[i, 5]:>11.4f}")

print("\n* = Puntos de izaje")

# -------------------------------
# ESFUERZOS M√ÅXIMOS
# -------------------------------
print("\n" + "="*70)
print("ESFUERZOS M√ÅXIMOS EN LOS NODOS")
print("="*70)

max_N_idx = np.argmax(np.abs(esfuerzos_nodales[:, 0]))
max_Vy_idx = np.argmax(np.abs(esfuerzos_nodales[:, 1]))
max_My_idx = np.argmax(np.abs(esfuerzos_nodales[:, 4]))
max_Mz_idx = np.argmax(np.abs(esfuerzos_nodales[:, 5]))
max_Tx_idx = np.argmax(np.abs(esfuerzos_nodales[:, 3]))

print(f"M√°xima fuerza axial (N):")
print(f"  Nodo N{max_N_idx+1}: {esfuerzos_nodales[max_N_idx, 0]:.4f} kN")

print(f"\nM√°ximo cortante vertical (Vy):")
print(f"  Nodo N{max_Vy_idx+1}: {esfuerzos_nodales[max_Vy_idx, 1]:.4f} kN")

print(f"\nM√°ximo momento flector My:")
print(f"  Nodo N{max_My_idx+1}: {esfuerzos_nodales[max_My_idx, 4]:.4f} kN¬∑m")

print(f"\nM√°ximo momento flector Mz:")
print(f"  Nodo N{max_Mz_idx+1}: {esfuerzos_nodales[max_Mz_idx, 5]:.4f} kN¬∑m")

print(f"\nM√°ximo momento torsor (Tx):")
print(f"  Nodo N{max_Tx_idx+1}: {esfuerzos_nodales[max_Tx_idx, 3]:.4f} kN¬∑m")



# -------------------------------
# GR√ÅFICOS DE DIAGRAMAS POR NODO
# -------------------------------
print("\n" + "="*70)
print("GENERANDO DIAGRAMAS...")
print("="*70)

fig, axes = plt.subplots(5, 1, figsize=(16, 15))

# Diagrama de fuerza axial
axes[0].plot(nodos, esfuerzos_nodales[:, 0], 'o-', linewidth=2.5, markersize=8, color='blue', label='Fuerza Axial N')
axes[0].axhline(y=0, color='k', linestyle='--', linewidth=0.8, alpha=0.5)
axes[0].fill_between(nodos, esfuerzos_nodales[:, 0], alpha=0.3, color='blue')
axes[0].set_ylabel('N (kN)', fontweight='bold', fontsize=11)
axes[0].set_title('Diagrama de Fuerza Axial en Nodos', fontweight='bold', fontsize=13)
axes[0].grid(True, alpha=0.3)
axes[0].legend()

# ============================================
# CORRECCI√ìN EN L√çNEA ~530
# ============================================

# Diagrama de cortante vertical
axes[1].plot(nodos, esfuerzos_nodales[:, 1], 's-', 
             linewidth=2.5, markersize=8, color='red', label='Cortante Vy')
axes[1].axhline(y=0, color='k', linestyle='--', linewidth=0.8, alpha=0.5)
axes[1].fill_between(nodos, esfuerzos_nodales[:, 1], alpha=0.3, color='red')
axes[1].set_ylabel('Vy (kN)', fontweight='bold', fontsize=11)
axes[1].set_title('Diagrama de Cortante Vertical', fontweight='bold', fontsize=13)
axes[1].grid(True, alpha=0.3)
axes[1].legend()

# Diagrama de momento flector 
axes[2].plot(nodos, esfuerzos_nodales[:, 5], '^-', 
             linewidth=2.5, markersize=8, color='orange', label='Momento Mz')
axes[2].axhline(y=0, color='k', linestyle='--', linewidth=0.8, alpha=0.5)
axes[2].fill_between(nodos, esfuerzos_nodales[:, 5], alpha=0.3, color='orange')
axes[2].set_ylabel('Mz (kN¬∑m)', fontweight='bold', fontsize=11)  # ‚Üê CAMBIAR AQU√ç
axes[2].set_title('Diagrama de Momento Flector Mz (Flexi√≥n Vertical)', 
                  fontweight='bold', fontsize=13)  # ‚Üê ACLARAR T√çTULO
axes[2].grid(True, alpha=0.3)
axes[2].legend()

# Diagrama de deflexi√≥n vertical 
uy_values = [u_global[i*7 + 1] for i in range(num_nodos)]
axes[3].plot(nodos, uy_values, 'd-', 
             linewidth=2.5, markersize=8, color='purple', label='Deflexi√≥n v')
axes[3].axhline(y=0, color='k', linestyle='--', linewidth=0.8, alpha=0.5)
axes[3].fill_between(nodos, uy_values, alpha=0.3, color='purple')
axes[3].set_ylabel('Deflexi√≥n v (m)', fontweight='bold', fontsize=11)
axes[3].set_xlabel('Posici√≥n (m)', fontweight='bold', fontsize=11)
axes[3].set_title('Deflexi√≥n Vertical', fontweight='bold', fontsize=13)
axes[3].grid(True, alpha=0.3)
axes[3].legend()

# Diagrama de deflexi√≥n lateral 
uy_values = [u_global[i*7 + 2] for i in range(num_nodos)]
axes[4].plot(nodos, uy_values, 'd-', 
             linewidth=2.5, markersize=8, color='grey', label='Deflexi√≥n z')
axes[4].axhline(y=0, color='k', linestyle='--', linewidth=0.8, alpha=0.5)
axes[4].fill_between(nodos, uy_values, alpha=0.3, color='grey')
axes[4].set_ylabel('Deflexi√≥n z (m)', fontweight='bold', fontsize=11)
axes[4].set_xlabel('Posici√≥n (m)', fontweight='bold', fontsize=11)
axes[4].set_title('Deflexi√≥n Lateral', fontweight='bold', fontsize=13)
axes[4].grid(True, alpha=0.3)
axes[4].legend()


# Marcar puntos de izaje en todos los gr√°ficos
for ax in axes:
    ax.axvline(x=nodos[2], color='orange', linestyle=':', linewidth=2, alpha=0.7, label='Izaje')
    ax.axvline(x=nodos[6], color='orange', linestyle=':', linewidth=2, alpha=0.7)

plt.tight_layout()
plt.show()

print("‚úì Diagramas generados exitosamente")



# -------------------------------
# GEOMETR√çA DE LA SECCI√ìN PCI TIPO VI
# -------------------------------
import numpy as np
import matplotlib.pyplot as plt
from matplotlib.patches import Polygon
from matplotlib.collections import PatchCollection

# Dimensiones de la secci√≥n VI en METROS (convertidas de pulgadas)
# 1 pulgada = 0.0254 metros

D1 = 1.829   # 1.8288 m
D2 = 0.127   # 0.127 m
D3 = 0.076    # 0.0762 m
D4 = 0.102    # 0.1016 m
D5 = 0.254   # 0.254 m
D6 = 0.203   # 0.2032 m

B1 = 1.067   # 1.0668 m
B2 = 0.711   # 0.7112 m
B3 = 0.203    # 0.2032 m
B4 = 0.102   # 0.1016 m
B5 = 0.330   # 0.3302 m
B6 = 0.254  # 0.254 m

print("\n" + "="*70)
print("DIMENSIONES DE LA SECCI√ìN PCI TIPO VI")
print("="*70)
print(f"Altura total (D1):        {D1:.4f} m")
print(f"Ancho superior (B1):      {B1:.4f} m")
print(f"Ancho inferior (B2):      {B2:.4f} m")
print(f"Ancho del alma:           {B3:.4f} m")

# -------------------------------
# DEFINIR COORDENADAS DE LA SECCI√ìN
# -------------------------------
def crear_seccion_VI():
    """
    Crea las coordenadas de los v√©rtices de la secci√≥n tipo VI
    El origen est√° en el centroide (aproximadamente a mitad de altura)
    """
    
    # Centroide aproximado (ajustar seg√∫n necesites)
    y_centroide = D1 / 2
    
    # Coordenadas de los v√©rtices (en sentido antihorario)
    # Parte superior (ala superior)
    vertices = []
    
    # Ala superior
    x1 = -B1/2
    x2 = B1/2
    y_top = D1 - y_centroide
    
    # Empezar desde esquina superior izquierda
    vertices.append([x1, y_top])
    vertices.append([x2, y_top])
    
    # Transici√≥n derecha superior
    vertices.append([x2, y_top - D2])
    vertices.append([x2 - (B1-B2)/2 + B3/2, y_top - D2 - D3])
    
    # Alma derecha
    vertices.append([B3/2, y_top - D2 - D3])
    vertices.append([B3/2, -y_centroide + D6 + D5])
    
    # Transici√≥n derecha inferior
    vertices.append([B3/2 + B4, -y_centroide + D6 + D5])
    vertices.append([B2/2, -y_centroide + D6])
    
    # Ala inferior derecha
    vertices.append([B2/2, -y_centroide])
    vertices.append([-B2/2, -y_centroide])
    
    # Transici√≥n izquierda inferior
    vertices.append([-B2/2, -y_centroide + D6])
    vertices.append([-(B3/2 + B4), -y_centroide + D6 + D5])
    
    # Alma izquierda
    vertices.append([-B3/2, -y_centroide + D6 + D5])
    vertices.append([-B3/2, y_top - D2 - D3])
    
    # Transici√≥n izquierda superior
    vertices.append([-(x2 - (B1-B2)/2 + B3/2), y_top - D2 - D3])
    vertices.append([x1, y_top - D2])
    
    return np.array(vertices)

# -------------------------------
# FUNCI√ìN PARA CALCULAR ESFUERZOS EN LA SECCI√ìN
# -------------------------------
def calcular_esfuerzos_seccion(N, Vy, My, Mz, nodo_num, vertices):
    """
    Calcula esfuerzos normales en la secci√≥n transversal
    œÉ = N/A + My*z/Iy - Mz*y/Iz
    
    Par√°metros:
    - N: Fuerza axial (kN)
    - Vy: Cortante vertical (kN)
    - My: Momento flector respecto a y (kN¬∑m)
    - Mz: Momento flector respecto a z (kN¬∑m)
    - nodo_num: N√∫mero del nodo
    - vertices: Coordenadas de la secci√≥n
    """
    
    # Propiedades geom√©tricas (ya las tienes definidas)
    A = PA  # √Årea
    Iy = PIF  # Momento de inercia respecto a y
    Iz = PID  # Momento de inercia respecto a z
    
    # Crear una malla de puntos en la secci√≥n
    y_min, y_max = vertices[:, 1].min(), vertices[:, 1].max()
    z_min, z_max = vertices[:, 0].min(), vertices[:, 0].max()
    
    # N√∫mero de puntos en la malla
    n_points = 100
    y_grid = np.linspace(y_min, y_max, n_points)
    z_grid = np.linspace(z_min, z_max, n_points)
    
    Z, Y = np.meshgrid(z_grid, y_grid)
    
    # Calcular esfuerzos normales en cada punto
    # œÉ = N/A + My*z/Iy - Mz*y/Iz
    # Nota: My genera esfuerzos que var√≠an con z, Mz genera esfuerzos que var√≠an con y
    
    sigma = (N * 1000) / A + (My * 1000000) * Z / Iy - (Mz * 1000000) * Y / Iz
    # Conversi√≥n: kN ‚Üí N, kN¬∑m ‚Üí N¬∑mm
    # Resultado en MPa (N/mm¬≤)
    sigma = sigma / 1000000  # Pa ‚Üí MPa
    
    # Crear m√°scara para puntos dentro de la secci√≥n
    from matplotlib.path import Path
    path = Path(vertices)
    points = np.column_stack([Z.ravel(), Y.ravel()])
    mask = path.contains_points(points).reshape(Z.shape)
    
    # Aplicar m√°scara
    sigma_masked = np.ma.masked_where(~mask, sigma)
    
    return Z, Y, sigma_masked, mask

# -------------------------------
# FUNCI√ìN PARA GRAFICAR ESFUERZOS EN UN NODO
# -------------------------------
def graficar_esfuerzos_nodo(nodo_idx, esfuerzos_nodales, nodos):
    """
    Grafica la distribuci√≥n de esfuerzos en la secci√≥n del nodo
    """
    
    # Extraer esfuerzos del nodo
    N = esfuerzos_nodales[nodo_idx, 0]    # kN
    Vy = esfuerzos_nodales[nodo_idx, 1]   # kN
    Vz = esfuerzos_nodales[nodo_idx, 2]   # kN
    Tx = esfuerzos_nodales[nodo_idx, 3]   # kN¬∑m
    My = esfuerzos_nodales[nodo_idx, 4]   # kN¬∑m
    Mz = esfuerzos_nodales[nodo_idx, 5]   # kN¬∑m
    
    # Crear geometr√≠a de la secci√≥n
    vertices = crear_seccion_VI()
    
    # Calcular esfuerzos
    Z, Y, sigma, mask = calcular_esfuerzos_seccion(N, Vy, My, Mz, nodo_idx+1, vertices)
    
    # Crear figura
    fig, (ax1, ax2) = plt.subplots(1, 2, figsize=(16, 8))
    
    # -------------------------------
    # Gr√°fico 1: Contorno de esfuerzos
    # -------------------------------
    
    # Dibujar contorno de la secci√≥n
    polygon = Polygon(vertices, fill=False, edgecolor='black', linewidth=2)
    ax1.add_patch(polygon)
    
    # Graficar esfuerzos
    levels = np.linspace(sigma.min(), sigma.max(), 20)
    contour = ax1.contourf(Z, Y, sigma, levels=levels, cmap='RdBu_r', extend='both')
    
    # L√≠nea de esfuerzo cero (eje neutro)
    ax1.contour(Z, Y, sigma, levels=[0], colors='black', linewidths=2, linestyles='--')
    
    # Colorbar
    cbar = plt.colorbar(contour, ax=ax1, label='Esfuerzo Normal œÉ (MPa)')
    
    # Etiquetas
    ax1.set_xlabel('z (m)', fontweight='bold', fontsize=11)
    ax1.set_ylabel('y (m)', fontweight='bold', fontsize=11)
    ax1.set_title(f'Distribuci√≥n de Esfuerzos - Nodo N{nodo_idx+1}\n'
                  f'Posici√≥n: {nodos[nodo_idx]:.2f} m', 
                  fontweight='bold', fontsize=13)
    ax1.set_aspect('equal')
    ax1.grid(True, alpha=0.3)
    
    # -------------------------------
    # Gr√°fico 2: Esfuerzos en 3D
    # -------------------------------
    ax2 = fig.add_subplot(122, projection='3d')
    
    # Superficie 3D de esfuerzos
    surf = ax2.plot_surface(Z, Y, sigma, cmap='RdBu_r', 
                           edgecolor='none', alpha=0.8)
    
    # Contorno de la secci√≥n en z=0
    for i in range(len(vertices)):
        j = (i + 1) % len(vertices)
        ax2.plot([vertices[i, 0], vertices[j, 0]], 
                [vertices[i, 1], vertices[j, 1]], 
                [0, 0], 'k-', linewidth=2)
    
    # Etiquetas
    ax2.set_xlabel('z (m)', fontweight='bold')
    ax2.set_ylabel('y (m)', fontweight='bold')
    ax2.set_zlabel('œÉ (MPa)', fontweight='bold')
    ax2.set_title(f'Esfuerzos 3D - Nodo N{nodo_idx+1}', fontweight='bold')
    
    # Colorbar
    fig.colorbar(surf, ax=ax2, shrink=0.5, aspect=5)
    
    # -------------------------------
    # Informaci√≥n de esfuerzos
    # -------------------------------
    info_text = f"""
    ESFUERZOS EN EL NODO N{nodo_idx+1}:
    
    Fuerza Axial (N):        {N:>10.4f} kN
    Cortante Vy:             {Vy:>10.4f} kN
    Cortante Vz:             {Vz:>10.4f} kN
    Momento My:              {My:>10.4f} kN¬∑m
    Momento Mz:              {Mz:>10.4f} kN¬∑m
    
    Esfuerzo m√°ximo:         {sigma.max():>10.4f} MPa
    Esfuerzo m√≠nimo:         {sigma.min():>10.4f} MPa
    """
    
    fig.text(0.5, 0.02, info_text, ha='center', fontsize=10, 
             family='monospace', bbox=dict(boxstyle='round', 
             facecolor='wheat', alpha=0.5))
    
    plt.tight_layout(rect=[0, 0.12, 1, 1])
    
    return fig


"""
C√ìDIGO PARA VISUALIZACI√ìN DE ESFUERZOS EN SECCI√ìN PCI VI
Para integrar directamente al c√≥digo de an√°lisis estructural

Sistema de unidades: SI
- Fuerzas: kN
- Momentos: kN¬∑m
- Longitudes: m
- Esfuerzos: MPa (se calculan internamente)
"""

import numpy as np
import matplotlib.pyplot as plt
from matplotlib.patches import Polygon
from matplotlib.path import Path
import matplotlib.patches as mpatches

# ==============================================================================
# FUNCIONES PARA CREAR GEOMETR√çA DE LA SECCI√ìN
# ==============================================================================

def crear_geometria_seccion_VI():
    """
    Crea las coordenadas de los v√©rtices de la secci√≥n PCI tipo VI
    Dimensiones en METROS (sistema SI)
    
    Retorna:
    --------
    vertices : array (n_vertices, 2)
        Coordenadas [z, y] de los v√©rtices de la secci√≥n
    """
    # Dimensiones de la secci√≥n VI en METROS
    D1 = 1.829   # Altura total
    D2 = 0.127
    D3 = 0.076
    D4 = 0.102
    D5 = 0.254
    D6 = 0.203
    
    B1 = 1.067   # Ancho superior
    B2 = 0.711   # Ancho inferior
    B3 = 0.203   # Ancho del alma
    B4 = 0.102
    
    # Centroide aproximado (a mitad de altura)
    y_centroide = D1 / 2
    
    # Coordenadas de los v√©rtices (sentido antihorario)
    vertices = []
    
    # Ala superior
    x1 = -B1/2
    x2 = B1/2
    y_top = D1 - y_centroide
    
    vertices.append([x1, y_top])
    vertices.append([x2, y_top])
    
    # Transici√≥n derecha superior
    vertices.append([x2, y_top - D2])
    vertices.append([x2 - (B1-B2)/2 + B3/2, y_top - D2 - D3])
    
    # Alma derecha
    vertices.append([B3/2, y_top - D2 - D3])
    vertices.append([B3/2, -y_centroide + D6 + D5])
    
    # Transici√≥n derecha inferior
    vertices.append([B3/2 + B4, -y_centroide + D6 + D5])
    vertices.append([B2/2, -y_centroide + D6])
    
    # Ala inferior
    vertices.append([B2/2, -y_centroide])
    vertices.append([-B2/2, -y_centroide])
    
    # Transici√≥n izquierda inferior
    vertices.append([-B2/2, -y_centroide + D6])
    vertices.append([-(B3/2 + B4), -y_centroide + D6 + D5])
    
    # Alma izquierda
    vertices.append([-B3/2, -y_centroide + D6 + D5])
    vertices.append([-B3/2, y_top - D2 - D3])
    
    # Transici√≥n izquierda superior
    vertices.append([-(x2 - (B1-B2)/2 + B3/2), y_top - D2 - D3])
    vertices.append([x1, y_top - D2])
    
    return np.array(vertices)


# ==============================================================================
# FUNCI√ìN PRINCIPAL PARA CALCULAR ESFUERZOS
# ==============================================================================

def calcular_esfuerzos_seccion(N, My, Mz, A, Iy, Iz, vertices, n_points=200):
    """
    Calcula la distribuci√≥n de esfuerzos normales en la secci√≥n transversal
    
    F√≥rmula de esfuerzos normales (flexi√≥n compuesta):
    œÉ = N/A + (My √ó z)/Iy - (Mz √ó y)/Iz
    
    Par√°metros:
    -----------
    N : float
        Fuerza axial [kN] (+ tensi√≥n, - compresi√≥n)
    My : float
        Momento flector respecto a eje y [kN¬∑m]
        (causa flexi√≥n en el plano horizontal)
    Mz : float
        Momento flector respecto a eje z [kN¬∑m]
        (causa flexi√≥n en el plano vertical)
    A : float
        √Årea de la secci√≥n [m¬≤]
    Iy : float
        Momento de inercia respecto a eje y [m‚Å¥]
    Iz : float
        Momento de inercia respecto a eje z [m‚Å¥]
    vertices : array
        Coordenadas de los v√©rtices de la secci√≥n
    n_points : int
        Resoluci√≥n de la malla
    
    Retorna:
    --------
    Z, Y : arrays 2D
        Coordenadas de la malla
    sigma : masked array 2D
        Esfuerzos normales [MPa]
    mask : array booleano
        M√°scara de puntos dentro de la secci√≥n
    """
    # L√≠mites de la secci√≥n
    y_min, y_max = vertices[:, 1].min(), vertices[:, 1].max()
    z_min, z_max = vertices[:, 0].min(), vertices[:, 0].max()
    
    # Crear malla de puntos
    y_grid = np.linspace(y_min, y_max, n_points)
    z_grid = np.linspace(z_min, z_max, n_points)
    Z, Y = np.meshgrid(z_grid, y_grid)
    
    # C√ÅLCULO DE ESFUERZOS NORMALES
    # ------------------------------
    # Sistema SI: kN, m ‚Üí Pa ‚Üí MPa
    
    # T√©rmino 1: Esfuerzo axial uniforme
    # N est√° en kN ‚Üí convertir a N ‚Üí dividir por A en m¬≤
    sigma_axial = (N * 1000) / A  # Pa
    
    # T√©rmino 2: Esfuerzo por momento My
    # My est√° en kN¬∑m ‚Üí convertir a N¬∑m
    # z est√° en m, Iy en m‚Å¥
    sigma_My = (My * 1000) * Z / Iy  # Pa
    
    # T√©rmino 3: Esfuerzo por momento Mz
    # Mz est√° en kN¬∑m ‚Üí convertir a N¬∑m
    # y est√° en m, Iz en m‚Å¥
    sigma_Mz = -(Mz * 1000) * Y / Iz  # Pa
    
    # Esfuerzo total
    sigma = sigma_axial + sigma_My + sigma_Mz  # Pa
    
    # Convertir a MPa para visualizaci√≥n
    sigma = sigma / 1e6  # MPa
    
    # Crear m√°scara para puntos dentro de la secci√≥n
    path = Path(vertices)
    points = np.column_stack([Z.ravel(), Y.ravel()])
    mask = path.contains_points(points).reshape(Z.shape)
    
    # Aplicar m√°scara
    sigma_masked = np.ma.masked_where(~mask, sigma)
    
    return Z, Y, sigma_masked, mask



# ============================================================================
# SECCI√ìN ADICIONAL: DIAGRAMAS CORREGIDOS DE CORTANTE Y MOMENTO
# ============================================================================
# Este c√≥digo se a√±ade AL FINAL de tu script existente (despu√©s de tus gr√°ficos)
# NO modifica ni elimina nada de tu c√≥digo original
# Genera diagramas adicionales usando el m√©todo correcto
# ============================================================================

print("\n\n" + "="*80)
print("GENERANDO DIAGRAMAS ADICIONALES (M√âTODO CORRECTO CON FUNCIONES DE HERMITE)")
print("="*80)

# ----------------------------------------------------------------------------
# FUNCI√ìN PARA CALCULAR V(x) Y M(x) EN UN ELEMENTO
# ----------------------------------------------------------------------------

def calcular_VM_correcto(x_local, L, vi, thetazi, vj, thetazj, q_dist, EI):
    """
    Calcula cortante V y momento M usando funciones de forma de Hermite
    
    Este es el m√©todo correcto que considera:
    - Desplazamientos de la viga (de u_global)
    - Cargas distribuidas
    - Relaci√≥n matem√°tica: V = dM/dx
    
    Par√°metros:
    -----------
    x_local : float
        Posici√≥n dentro del elemento [0, L] en metros
    L : float
        Longitud del elemento en metros
    vi, vj : float
        Desplazamientos verticales en nodos i y j [m]
    thetazi, thetazj : float
        Rotaciones en nodos i y j [rad]
    q_dist : float
        Carga distribuida [kN/m] (positiva hacia abajo)
    EI : float
        Rigidez a flexi√≥n [kN¬∑m¬≤]
    
    Retorna:
    --------
    V, M : floats
        Cortante [kN] y Momento [kN¬∑m] en la posici√≥n x_local
    """
    
    if L <= 0 or x_local < 0 or x_local > L:
        return 0.0, 0.0
    
    # Coordenada local normalizada
    xi = x_local / L
    
    # ------------------------------------------------------
    # FUNCIONES DE FORMA DE HERMITE
    # ------------------------------------------------------
    # Estas funciones interpolan los desplazamientos
    N1 = 1 - 3*xi**2 + 2*xi**3
    N2 = L * (xi - 2*xi**2 + xi**3)
    N3 = 3*xi**2 - 2*xi**3
    N4 = L * (-xi**2 + xi**3)
    
    # ------------------------------------------------------
    # SEGUNDA DERIVADA (para momento)
    # ------------------------------------------------------
    # M = -EI¬∑d¬≤v/dx¬≤
    d2N1_dx2 = (12*xi - 6) / L**2
    d2N2_dx2 = (6*xi - 4) / L
    d2N3_dx2 = (-12*xi + 6) / L**2
    d2N4_dx2 = (6*xi - 2) / L
    
    # Curvatura
    d2v = d2N1_dx2 * vi + d2N2_dx2 * thetazi + d2N3_dx2 * vj + d2N4_dx2 * thetazj
    
    # Momento por deformaci√≥n el√°stica
    M_elastico = -EI * d2v
    
    # ------------------------------------------------------
    # TERCERA DERIVADA (para cortante)
    # ------------------------------------------------------
    # V = -EI¬∑d¬≥v/dx¬≥
    d3N1_dx3 = 12 / L**3
    d3N2_dx3 = 6 / L**2
    d3N3_dx3 = -12 / L**3
    d3N4_dx3 = 6 / L**2
    
    # Tercera derivada
    d3v = d3N1_dx3 * vi + d3N2_dx3 * thetazi + d3N3_dx3 * vj + d3N4_dx3 * thetazj
    
    # Cortante por deformaci√≥n el√°stica
    V_elastico = -EI * d3v
    
    # ------------------------------------------------------
    # CONTRIBUCI√ìN DE LA CARGA DISTRIBUIDA
    # ------------------------------------------------------
    # Momento adicional (parab√≥lico)
    M_carga = (q_dist * x_local * (L - x_local)) / 2
    
    # Cortante adicional (lineal)
    V_carga = q_dist * (L/2 - x_local)
    
    # ------------------------------------------------------
    # ESFUERZOS TOTALES
    # ------------------------------------------------------
    M_total = M_elastico + M_carga
    V_total = V_elastico + V_carga
    
    return V_total, M_total


# ----------------------------------------------------------------------------
# CALCULAR DIAGRAMAS CORREGIDOS EN TODA LA VIGA
# ----------------------------------------------------------------------------

print("\nCalculando diagramas con m√©todo de funciones de Hermite...")

# Arreglos para almacenar resultados
x_corregido = []      # Posiciones [m]
V_corregido = []      # Cortantes [kN]
M_corregido = []      # Momentos [kN¬∑m]

# N√∫mero de puntos de evaluaci√≥n por elemento (alta resoluci√≥n)
n_puntos = 80

# Rigidez a flexi√≥n
EI = E * PIF  # [kN¬∑m¬≤]

# Recorrer cada elemento
for i_elem in range(num_nodos - 1):
    
    # Posiciones globales del elemento
    xi_global = nodos[i_elem]
    xj_global = nodos[i_elem + 1]
    L_elem = xj_global - xi_global
    
    # Saltar elementos degenerados
    if L_elem <= 1e-6:
        continue
    
    # Extraer desplazamientos nodales
    base_i = i_elem * 7
    base_j = (i_elem + 1) * 7
    
    vi = u_global[base_i + 1]        # Desplazamiento vertical nodo i
    thetazi = u_global[base_i + 5]   # Rotaci√≥n Œ∏z nodo i
    vj = u_global[base_j + 1]        # Desplazamiento vertical nodo j
    thetazj = u_global[base_j + 5]   # Rotaci√≥n Œ∏z nodo j
    
    # Evaluar en m√∫ltiples puntos dentro del elemento
    x_locales = np.linspace(0, L_elem, n_puntos)
    
    for x_local in x_locales:
        x_global = xi_global + x_local
        
        # Calcular cortante y momento con el m√©todo correcto
        V, M = calcular_VM_correcto(
            x_local, L_elem, 
            vi, thetazi, vj, thetazj,
            q, EI
        )
        
        # Almacenar resultados
        x_corregido.append(x_global)
        V_corregido.append(V)
        M_corregido.append(M)

# Convertir a arrays
x_corregido = np.array(x_corregido)
V_corregido = np.array(V_corregido)
M_corregido = np.array(M_corregido)

print(f"‚úì {len(x_corregido)} puntos calculados en {num_nodos-1} elementos")


# ----------------------------------------------------------------------------
# COMPARACI√ìN CON M√âTODO NODAL ORIGINAL
# ----------------------------------------------------------------------------

print("\n" + "="*80)
print("COMPARACI√ìN: M√âTODO NODAL vs M√âTODO DE HERMITE")
print("="*80)

# Tu m√©todo original (esfuerzos nodales)
V_nodal = esfuerzos_nodales[:, 1]  # Cortante Vy de tu c√≥digo
M_nodal = esfuerzos_nodales[:, 5]  # Momento Mz de tu c√≥digo

print("\nM√âTODO NODAL (tu c√≥digo original):")
print(f"  Cortante m√°ximo:  {V_nodal.max():>10.2f} kN")
print(f"  Cortante m√≠nimo:  {V_nodal.min():>10.2f} kN")
print(f"  Momento m√°ximo:   {M_nodal.max():>10.2f} kN¬∑m")
print(f"  Momento m√≠nimo:   {M_nodal.min():>10.2f} kN¬∑m")

print("\nM√âTODO DE HERMITE (m√©todo correcto):")
print(f"  Cortante m√°ximo:  {V_corregido.max():>10.2f} kN")
print(f"  Cortante m√≠nimo:  {V_corregido.min():>10.2f} kN")
print(f"  Momento m√°ximo:   {M_corregido.max():>10.2f} kN¬∑m")
print(f"  Momento m√≠nimo:   {M_corregido.min():>10.2f} kN¬∑m")

# Diferencias
print("\nDIFERENCIAS:")
print(f"  ŒîV_max = {abs(V_corregido.max() - V_nodal.max()):>10.2f} kN")
print(f"  ŒîM_max = {abs(M_corregido.max() - M_nodal.max()):>10.2f} kN¬∑m")


# ----------------------------------------------------------------------------
# VERIFICACI√ìN: V = dM/dx
# ----------------------------------------------------------------------------

print("\n" + "="*80)
print("VERIFICACI√ìN MATEM√ÅTICA: V = dM/dx")
print("="*80)

# Calcular derivada num√©rica del momento
dM_dx = np.gradient(M_corregido, x_corregido)

# Error entre cortante calculado y derivada del momento
error_V_dM = np.abs(V_corregido - dM_dx)
error_medio = np.mean(error_V_dM)
error_max = np.max(error_V_dM)

print(f"\nError en la relaci√≥n V = dM/dx:")
print(f"  Error medio:  {error_medio:.4f} kN")
print(f"  Error m√°ximo: {error_max:.4f} kN")

if error_medio < 1.0:
    print("  ‚úì VERIFICACI√ìN EXITOSA: Los diagramas corregidos cumplen V = dM/dx")
else:
    print("  ‚ö† Advertencia: Error elevado")


# ----------------------------------------------------------------------------
# GR√ÅFICOS COMPARATIVOS
# ----------------------------------------------------------------------------

print("\n" + "="*80)
print("GENERANDO GR√ÅFICOS COMPARATIVOS...")
print("="*80)

# Crear figura con 2 filas y 2 columnas
fig = plt.figure(figsize=(20, 12))

# ============================================
# FILA 1: CORTANTE
# ============================================

# Gr√°fico 1: Cortante - M√©todo Nodal (tu c√≥digo original)
ax1 = plt.subplot(2, 2, 1)
ax1.plot(nodos, V_nodal, 's-', linewidth=2.5, markersize=8, color='red', 
         label='Cortante Vy (Nodal)', zorder=3)
ax1.fill_between(nodos, V_nodal, 0, alpha=0.3, color='red', zorder=2)
ax1.axhline(y=0, color='k', linestyle='--', linewidth=0.8, alpha=0.5)

# Marcar apoyos
for i_apoyo in [2, 6]:
    ax1.axvline(x=nodos[i_apoyo], color='blue', linestyle=':', 
                linewidth=2, alpha=0.7)

ax1.set_ylabel('Cortante Vy (kN)', fontweight='bold', fontsize=12)
ax1.set_title('M√âTODO NODAL (Tu c√≥digo original)\nCortante en nodos', 
              fontweight='bold', fontsize=13)
ax1.grid(True, alpha=0.3)
ax1.legend(fontsize=10)
ax1.set_xlim([0, LTOTAL])

# Gr√°fico 2: Cortante - M√©todo de Hermite (corregido)
ax2 = plt.subplot(2, 2, 2)
ax2.plot(x_corregido, V_corregido, '-', linewidth=2.5, color='darkred', 
         label='Cortante Vy (Hermite)', zorder=3)
ax2.fill_between(x_corregido, V_corregido, 0, alpha=0.3, color='red', zorder=2)
ax2.axhline(y=0, color='k', linestyle='--', linewidth=0.8, alpha=0.5)

# Marcar apoyos y reacciones
for idx, i_apoyo in enumerate([2, 6]):
    x_apoyo = nodos[i_apoyo]
    color = 'blue' if idx == 0 else 'green'
    R = R_v3 if idx == 0 else R_v7
    
    ax2.axvline(x=x_apoyo, color=color, linestyle=':', linewidth=2.5, alpha=0.8)
    ax2.text(x_apoyo, V_corregido.max()*0.3, f'R={R:.1f} kN',
             fontsize=9, ha='center', fontweight='bold', color=color,
             bbox=dict(boxstyle='round', facecolor='white', edgecolor=color))

ax2.set_ylabel('Cortante Vy (kN)', fontweight='bold', fontsize=12)
ax2.set_title('M√âTODO DE HERMITE (Correcto)\nCortante continuo con V=dM/dx', 
              fontweight='bold', fontsize=13, color='darkgreen')
ax2.grid(True, alpha=0.3)
ax2.legend(fontsize=10)
ax2.set_xlim([0, LTOTAL])

# ============================================
# FILA 2: MOMENTO
# ============================================

# Gr√°fico 3: Momento - M√©todo Nodal (tu c√≥digo original)
ax3 = plt.subplot(2, 2, 3)
ax3.plot(nodos, M_nodal, '^-', linewidth=2.5, markersize=8, color='orange', 
         label='Momento Mz (Nodal)', zorder=3)
ax3.fill_between(nodos, M_nodal, 0, alpha=0.3, color='orange', zorder=2)
ax3.axhline(y=0, color='k', linestyle='--', linewidth=0.8, alpha=0.5)

# Marcar apoyos
for i_apoyo in [2, 6]:
    ax3.axvline(x=nodos[i_apoyo], color='blue', linestyle=':', 
                linewidth=2, alpha=0.7)

ax3.set_ylabel('Momento Mz (kN¬∑m)', fontweight='bold', fontsize=12)
ax3.set_xlabel('Posici√≥n (m)', fontweight='bold', fontsize=12)
ax3.set_title('M√âTODO NODAL (Tu c√≥digo original)\nMomento en nodos', 
              fontweight='bold', fontsize=13)
ax3.grid(True, alpha=0.3)
ax3.legend(fontsize=10)
ax3.set_xlim([0, LTOTAL])

# Gr√°fico 4: Momento - M√©todo de Hermite (corregido)
ax4 = plt.subplot(2, 2, 4)
ax4.plot(x_corregido, M_corregido, '-', linewidth=2.5, color='darkorange', 
         label='Momento Mz (Hermite)', zorder=3)
ax4.fill_between(x_corregido, M_corregido, 0, alpha=0.35, color='orange', zorder=2)
ax4.axhline(y=0, color='k', linestyle='--', linewidth=0.8, alpha=0.5)

# Marcar apoyos
for idx, i_apoyo in enumerate([2, 6]):
    x_apoyo = nodos[i_apoyo]
    color = 'blue' if idx == 0 else 'green'
    ax4.axvline(x=x_apoyo, color=color, linestyle=':', linewidth=2.5, alpha=0.8)

# Marcar m√°ximo
idx_M_max = np.argmax(M_corregido)
ax4.plot(x_corregido[idx_M_max], M_corregido[idx_M_max], 'o', 
         color='darkred', markersize=12, markeredgecolor='black', 
         markeredgewidth=2, label=f'M_m√°x = {M_corregido[idx_M_max]:.2f} kN¬∑m', 
         zorder=5)

ax4.set_ylabel('Momento Mz (kN¬∑m)', fontweight='bold', fontsize=12)
ax4.set_xlabel('Posici√≥n (m)', fontweight='bold', fontsize=12)
ax4.set_title('M√âTODO DE HERMITE (Correcto)\nMomento continuo derivable', 
              fontweight='bold', fontsize=13, color='darkgreen')
ax4.grid(True, alpha=0.3)
ax4.legend(fontsize=10)
ax4.set_xlim([0, LTOTAL])

# T√≠tulo general
fig.suptitle('COMPARACI√ìN DE M√âTODOS: NODAL vs HERMITE\n' + 
             'Izquierda: Tu c√≥digo original (solo nodos) | Derecha: M√©todo correcto (continuo)',
             fontsize=16, fontweight='bold', y=0.98)

plt.tight_layout(rect=[0, 0, 1, 0.96])

print("‚úì Gr√°ficos comparativos generados")


# ----------------------------------------------------------------------------
# GR√ÅFICO ADICIONAL: SOLO DIAGRAMAS CORREGIDOS (LIMPIO)
# ----------------------------------------------------------------------------

print("\nGenerando gr√°ficos de diagramas corregidos (versi√≥n limpia)...")

fig2, axes2 = plt.subplots(2, 1, figsize=(18, 12))

# ============================================
# CORTANTE CORREGIDO
# ============================================
ax_V = axes2[0]

ax_V.plot(x_corregido, V_corregido, 'r-', linewidth=3, 
          label='Cortante Vy', zorder=3)
ax_V.fill_between(x_corregido, V_corregido, 0, alpha=0.3, color='red', zorder=2)
ax_V.axhline(y=0, color='black', linestyle='--', linewidth=1, alpha=0.7)

# Marcar apoyos con reacciones
colores = ['blue', 'green']
for idx, i_apoyo in enumerate([2, 6]):
    x_apoyo = nodos[i_apoyo]
    R = R_v3 if idx == 0 else R_v7
    color = colores[idx]
    nombre = 'N3' if idx == 0 else 'N7'
    
    ax_V.axvline(x=x_apoyo, color=color, linestyle=':', linewidth=2.5, 
                 alpha=0.8, label=f'Apoyo {nombre}', zorder=4)
    
    y_pos = V_corregido.max() * 0.4
    ax_V.annotate(f'R_{nombre} = {R:.1f} kN', 
                  xy=(x_apoyo, 0), xytext=(x_apoyo, y_pos),
                  fontsize=12, ha='center', fontweight='bold', color=color,
                  arrowprops=dict(arrowstyle='->', lw=2.5, color=color),
                  bbox=dict(boxstyle='round,pad=0.5', facecolor='white', 
                           edgecolor=color, alpha=0.95),
                  zorder=5)

ax_V.set_ylabel('Cortante Vy (kN)', fontweight='bold', fontsize=14)
ax_V.set_title('Diagrama de Cortante Vertical - M√âTODO CORRECTO (Funciones de Hermite)\n' +
               'Incluye efecto de cargas distribuidas y cumple V = dM/dx', 
               fontweight='bold', fontsize=15, pad=15)
ax_V.grid(True, alpha=0.4, linestyle='--')
ax_V.legend(fontsize=12, loc='best', framealpha=0.95)
ax_V.set_xlim([0, LTOTAL])

# Valores extremos
V_max_val = V_corregido.max()
V_min_val = V_corregido.min()
idx_Vmax = np.argmax(V_corregido)
idx_Vmin = np.argmin(V_corregido)
ax_V.plot(x_corregido[idx_Vmax], V_max_val, 'r*', markersize=20, zorder=6)
ax_V.plot(x_corregido[idx_Vmin], V_min_val, 'b*', markersize=20, zorder=6)

# ============================================
# MOMENTO CORREGIDO
# ============================================
ax_M = axes2[1]

ax_M.plot(x_corregido, M_corregido, '-', color='darkorange', linewidth=3, 
          label='Momento Mz', zorder=3)
ax_M.fill_between(x_corregido, M_corregido, 0, alpha=0.35, color='orange', zorder=2)
ax_M.axhline(y=0, color='black', linestyle='--', linewidth=1, alpha=0.7)

# Marcar apoyos
for idx, i_apoyo in enumerate([2, 6]):
    x_apoyo = nodos[i_apoyo]
    color = colores[idx]
    nombre = 'N3' if idx == 0 else 'N7'
    
    ax_M.axvline(x=x_apoyo, color=color, linestyle=':', linewidth=2.5, 
                 alpha=0.8, label=f'Apoyo {nombre}', zorder=4)

ax_M.set_ylabel('Momento Mz (kN¬∑m)', fontweight='bold', fontsize=14)
ax_M.set_xlabel('Posici√≥n a lo largo de la viga (m)', fontweight='bold', fontsize=14)
ax_M.set_title('Diagrama de Momento Flector - M√âTODO CORRECTO (Funciones de Hermite)\n' +
               'Verificado: dM/dx = V', 
               fontweight='bold', fontsize=15, pad=15)
ax_M.grid(True, alpha=0.4, linestyle='--')
ax_M.legend(fontsize=12, loc='best', framealpha=0.95)
ax_M.set_xlim([0, LTOTAL])

# Valores extremos
M_max_val = M_corregido.max()
M_min_val = M_corregido.min()
idx_Mmax = np.argmax(M_corregido)
idx_Mmin = np.argmin(M_corregido)
ax_M.plot(x_corregido[idx_Mmax], M_max_val, 'o', color='darkred', markersize=14,
          markeredgecolor='black', markeredgewidth=2,
          label=f'M_m√°x = {M_max_val:.2f} kN¬∑m @ x={x_corregido[idx_Mmax]:.2f}m', 
          zorder=6)
ax_M.plot(x_corregido[idx_Mmin], M_min_val, 'o', color='darkblue', markersize=14,
          markeredgecolor='black', markeredgewidth=2,
          label=f'M_m√≠n = {M_min_val:.2f} kN¬∑m @ x={x_corregido[idx_Mmin]:.2f}m', 
          zorder=6)

ax_M.legend(fontsize=11, loc='best', framealpha=0.95)

plt.tight_layout()

print("‚úì Gr√°ficos de diagramas corregidos generados")


# ----------------------------------------------------------------------------
# RESUMEN FINAL
# ----------------------------------------------------------------------------

print("\n" + "="*80)
print("RESUMEN DE DIAGRAMAS CORREGIDOS")
print("="*80)

print(f"\nDIAGRAMA DE CORTANTE:")
print(f"  V m√°ximo:  {V_max_val:>10.2f} kN  en x = {x_corregido[idx_Vmax]:>6.2f} m")
print(f"  V m√≠nimo:  {V_min_val:>10.2f} kN  en x = {x_corregido[idx_Vmin]:>6.2f} m")

print(f"\nDIAGRAMA DE MOMENTO:")
print(f"  M m√°ximo:  {M_max_val:>10.2f} kN¬∑m  en x = {x_corregido[idx_Mmax]:>6.2f} m")
print(f"  M m√≠nimo:  {M_min_val:>10.2f} kN¬∑m  en x = {x_corregido[idx_Mmin]:>6.2f} m")

print(f"\nREACCIONES EN APOYOS:")
print(f"  R_v3 (N3 @ x={nodos[2]:.2f}m):  {R_v3:.2f} kN")
print(f"  R_v7 (N7 @ x={nodos[6]:.2f}m):  {R_v7:.2f} kN")
print(f"  Suma:                           {R_v3+R_v7:.2f} kN")
print(f"  Peso total viga:                {q*LTOTAL:.2f} kN")
print(f"  Equilibrio (diferencia):        {abs((R_v3+R_v7) - q*LTOTAL):.4f} kN")

print("\n" + "="*80)
print("‚úì DIAGRAMAS CORREGIDOS COMPLETADOS")
print("="*80)
print("\nCARACTER√çSTICAS DE LOS DIAGRAMAS CORREGIDOS:")
print("  ‚úì Calculados con funciones de forma de Hermite")
print("  ‚úì Consideran desplazamientos reales (de u_global)")
print("  ‚úì Incluyen efecto de cargas distribuidas")
print("  ‚úì Cumplen la relaci√≥n matem√°tica V = dM/dx")
print("  ‚úì Son continuos y diferenciables")
print("  ‚úì Verifican equilibrio global")
print("\nTU C√ìDIGO ORIGINAL SE MANTIENE INTACTO")
print("Los esfuerzos nodales siguen disponibles en 'esfuerzos_nodales'")
print("="*80)

# Mostrar todos los gr√°ficos
plt.show()

print("\n‚úÖ Proceso completado exitosamente")
